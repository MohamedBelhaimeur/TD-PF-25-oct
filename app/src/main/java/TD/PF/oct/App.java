/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package TD.PF.oct;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;


import TD.PF.oct.universite.*;


public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        System.out.println(new App().getGreeting());
  //Q1      
        Somme<Integer> sommerdeuxEntier
        = new Somme<Integer>() {

			@Override
			public Integer somme(Integer arg1, Integer args2) {
				// TODO Auto-generated method stub
				return arg1+args2;
			}
       
    };
    
    Somme<String> sommerdeuxString
    = new Somme<String>() {

		@Override
		public String somme(String arg1, String args2) {
			// TODO Auto-generated method stub
			return arg1.concat(args2);
		}
   
};
Somme<Double> sommerdeuxdoubles
= new Somme<Double>() {

	@Override
	public Double somme(Double arg1, Double args2) {
		// TODO Auto-generated method stub
		return arg1+args2;
	}

};
Somme<Long> sommerdeuxlongs
= new Somme<Long>() {

	@Override
	public Long somme(Long arg1, Long args2) {
		// TODO Auto-generated method stub
		return arg1+args2;
	}

};

//Q2
ToString<List<String>> convertirenstring=new ToString<List<String>>() {
	
	@Override
	public String convertir(List<String> arg) {
		// TODO Auto-generated method stub
		String texte="";
		for (String index:arg) {
			texte=texte+index+", ";
		}
		return texte;
			}
};


/*Q3
 Function: Convertie (map) un type vers un autre. Lambda avec une variable
Stockage de lambda expression : signature (T)  R

Predicate: Tests l’argument selon un critère et renvoie vrai ou faux. Stockage Lambda expression : signature (T)  boolean

Consumer : Consume une entrée et ne retourne rien Stockage Lambda expression : signature (T)  void

Supplier : Générer une sortie Stockage Lambda expression : signature ()  T
 */


    //Exo 2 q1)
    Predicate<Integer> tailleTropPetite =(s) -> s<100;
    Predicate<Integer> tailleTropGrande =(s) -> s>200;
    Predicate<Integer> tailleIcorrecte= tailleTropPetite.or(tailleTropGrande);
    Predicate<Integer> taillecorrecte=tailleIcorrecte.negate();
    Predicate<Double>poidtroplourd=t->t>150.0;
    Predicate<Double>poidcorrecte=poidtroplourd.negate();
    Predicate<Paire<Integer, Double>>accesautorise=
    		(Paire<Integer,Double>client) ->taillecorrecte.test(client.taille) && poidcorrecte.test(client.poid);
    		
    		
    		Matiere m1 = new Matiere("MAT1");
    		Matiere m2 = new Matiere("MAT2");
    		UE ue1 = new UE("UE1", Map.of(m1, 2, m2, 2));
    		Matiere m3 = new Matiere("MAT3");
    		UE ue2 = new UE("UE2", Map.of(m3, 1));
    		Annee a1 = new Annee(Set.of(ue1, ue2));
    
    		Etudiant e1 = new Etudiant("39001", "Alice", "Merveille",a1);
    		e1.noter(m1, 12.0);
    		e1.noter(m2, 14.0);
    		e1.noter(m3, 10.0);
    		System.out.println(e1);
    		Etudiant e2 = new Etudiant("39002", "Bob", "Eponge", a1);
    		e2.noter(m1, 14.0);
    		e2.noter(m3, 14.0);
    		Etudiant e3 = new Etudiant("39003", "Charles", "Chaplin", a1);
    		e3.noter(m1, 18.0);
    		e3.noter(m2, 5.0);
    		e3.noter(m3, 14.0);
    		
    
}
    public static void afficheSi(String entete,Predicate<Etudiant> etudiant,Annee a,List<Etudiant>etudiants) {
    	
		 
	 }
   
    
}
